include: "Common.snake"

import glob
import os
import re

#FIXME move StrainAnalysis out of binning folder

def bin_paths_by_type(bin_type):
  return [os.path.dirname(path) for path in glob.glob("subgraphs/%s/Bin_*/SCG.fna" % bin_type)]

INIT_BIN_PATHS=bin_paths_by_type("Bin_ini")

#TODO think of a better flag name
rule all:
    input: "heavylifting.done"

rule extract_subgraphs:
    input:   cogs="subgraphs/{bin_type}/{bin}/SCG.fna",
             gfa="assembly/high_res/simplified.gfa"
    output:  touch("subgraphs/{bin_type}/{bin}/subgraph.done")
    log:     "subgraphs/{bin_type}/{bin}/subgraph.log"
    threads: THREADS
    shell:   "{SOFT}/subgraph-extractor -part-seq {input.cogs} -graph {input.gfa} -o $(dirname {output}) -k {ASSEMBLY_K} -t {threads} -cds-len-est {SCG_DATA}/coreCogs.tsv> {log}"

rule create_unitig_profile:
    input: flag="subgraphs/{bin_type}/{bin}/subgraph.done",
           mult_prof="assembly/high_res/simplified.mult_prof"
    output: touch('subgraphs/{bin_type}/{bin}/profile.done')
    shell:  """
            rm -rf $(dirname {input.flag})/*.tsv
            for file in $(dirname {input.flag})/*gfa; do
                stub=${{file%.gfa}}
                awk '/^S/{{print ">"$2"\\n"$3 }}' $file | grep ">" | sed 's/>//g' > $stub.id    
                awk 'FNR==NR {{hash[$1]; next}} $1 in hash' $stub.id {input.mult_prof} > ${{stub}}.tsv
                rm $stub.id
            done
            """

#FIXME do I need to specify tmp folder
#TODO refactor (maybe without a loop)
rule simplify_subgraphs:
    input: "subgraphs/{bin_type}/{bin}/profile.done"
    output: touch('subgraphs/{bin_type}/{bin}/simplif.done')
    params:
    threads: THREADS
    run:
      BIN_AVG_COV=dict()
      Path="/".join(["subgraphs",wildcards["bin_type"],"bin_cov.tsv"])
      for l in open(Path):
          bin, cov = l.strip().split()
          BIN_AVG_COV["Bin_" + bin] = cov
      avg_cov = BIN_AVG_COV[wildcards["bin"]]
      shell("""
            out=$(dirname {output})/simplif
            rm -rf $out
            mkdir -p $out/tmp
            in=$(dirname {input})
            for g in $in/*gfa; do
                name=$(basename $g .gfa)
                {SOFT}/spades-gsimplifier $g $out/$name --gfa -k {ASSEMBLY_K} -s $in/$name.stops -d $in/$name.deadends -p $in/$name.tsv -c {avg_cov} -read-length {READ_LENGTH} -t {threads} -tmpdir $out/tmp &> $out/$name.log
            done
            """)

#TODO ask Seb why we need these methods and checkpoint_output variables
def get_list_subgraph_done(wildcards):
  checkpoints.fuse.get(bin_type=wildcards["bin_type"])
  return expand("{path}/simplif.done", path = bin_paths_by_type(wildcards["bin_type"]))
 
#TODO why 'fuse'? :)
checkpoint fuse:
    input : "subgraphs/{bin_type}/folder_done"
    output: touch("subgraphs/{bin_type}/fuse.done")

rule Check_out_which_bins_need_dereplication :
    input:   flag=get_list_subgraph_done
    output:  ignore="subgraphs/{bin_type}/List_bin_cogs_to_ignore.tsv",
             merge="subgraphs/{bin_type}/List_bin_to_merge.tsv"
    shell:   "{SCRIPTS}/Common_unitigs.py $(dirname {output.ignore})/'Bin*/simplif/COG*.gfa' 10 $(dirname {output.ignore})/"

#TODO review logic and maybe move to scripts / separate into multiple rules
#FIXME normalize variable names and spacing
checkpoint Merge_Bins :
    input:   "subgraphs/Bin_ini/List_bin_to_merge.tsv",
             "binning/clustering_gt%s_merged.csv"%MIN_CONTIG_SIZE
    output:  "subgraphs/Merged_Bin/bin_cov.tsv",
             "subgraphs/Merged_Bin/clustering_gt%s_merged.csv"%MIN_CONTIG_SIZE,
              touch("subgraphs/Merged_Bin/folder_done")
    run:
      # merge and remove old bins
      List_all_bins=[re.search("Bin_\d+",bin).group() for bin in INIT_BIN_PATHS]
      Set_merged_bin=set()
      for line in open(input[0]) :
        Split_line=line.rstrip().split("\t")
        name_new_bin=Split_line[0]
        List_bins_to_merge=Split_line[1:]
        Set_merged_bin|=set(List_bins_to_merge)
        New_bin_path=os.path.join(os.path.dirname(output[0]),name_new_bin)
        os.system('mkdir -p '+New_bin_path)
        All_bins_element=lambda text:" ".join([os.path.join(os.path.dirname(input[0]),bin,text) for bin in List_bins_to_merge])
        os.system('cat '+All_bins_element("contigs.fa")+" > "+New_bin_path+"/contigs.fa")
        os.system('cat '+All_bins_element("SCG.fna")+" > "+New_bin_path+"/SCG.fna")
      # link all non merged bin in the merged bin folder
      for bins in set(List_all_bins)-Set_merged_bin :
        os.system("ln -s ../Bin_ini/"+bins+" "+os.path.dirname(output[0])+"/")
      # create a new contig assignation file 
      Dico_bin_new_name={element.replace("Bin_",""):line.rstrip().split()[0].replace("Bin_","") for line in open(input[0]) for element in  line.rstrip().split()[1:]}
      #TODO add to inputs
      Handle=open(output[1],"w")
      for line in open(input[1]) :
        contig,bins=line.rstrip().split(",")
        if bins in Dico_bin_new_name :
          Handle.write(",".join([contig,Dico_bin_new_name[bins]])+"\n")
        else :
          Handle.write(line)
      Handle.close()
      # redo the bin_cov.tsv file
      os.system(SCRIPTS+"/bin_cov.py " +output[1]+" "+output[0]+" "+str(ASSEMBLY_K))


rule flag_bad_cogs:
    input:  "subgraphs/{bin_type}/List_bin_cogs_to_ignore.tsv",
            "subgraphs/{bin_type}/{bin}/simplif.done"
    output:  "subgraphs/{bin_type}/{bin}/List_cogs_selected.tsv"
    run:
      os.system("touch "+output[0])
      with open(input[0]) as cogs_to_ignore :
        for line in cogs_to_ignore:
          Split_line = line.rstrip().split("\t")
          bin_name = Split_line[0]
          if bin_name == wildcards.bin:
            Set_cogs_to_flags = set()
            if len(Split_line) != 1:
              Set_cogs_to_flags = {cog for cog in Split_line[1:]}
            Cog_path = "/".join(["subgraphs", wildcards.bin_type, bin_name,""])
            List_cogs = [pathcog.split('/')[-1].split(".")[0] for pathcog in glob.glob(Cog_path + "COG*.gfa") if pathcog.split('/')[-1].split(".")[0] not in Set_cogs_to_flags]
            with open(Cog_path+"List_cogs_selected.tsv","w") as Handle :
              Handle.write("\n".join(sorted(List_cogs)))
  
#TODO review logic
def All_selected_cogs_files_from_merged_bin(wildcards):
    checkpoints.Merge_Bins.get(path="subgraphs")
    # since we linked non merged bins in the merged bin folder, bins in that folder are, at that point in time, the correct set of bin to consider. 
    return [binpath+"/List_cogs_selected.tsv" for binpath in bin_paths_by_type("Merged_Bin")]

checkpoint Select_Bin_to_run:
  input:  All_selected_cogs_files_from_merged_bin
  output: touch("subgraphs/Bin_Selected/bin_selected.done")
  message : "Select which bins possess sufficient number of COGs"
  run:
    # example of element for All_selected_cogs_files_from_merged_bin : subgraphs/Merged_Bin/Bin_11/List_cogs_selected.tsv
    for file in input:
      if len(list(open(file).readlines())) >= 10:
        Bin=os.path.dirname(file).split("/")[-1] # select bin_name only, not full path
        os.system("ln -s ../Merged_Bin/"+Bin+" "+ os.path.dirname(output[0])+"/")


rule BayesAGraphSVA:
    input:  flag="subgraphs/Bin_Selected/{bin}/simplif.done",
            Cogs="subgraphs/Bin_Selected/{bin}/List_cogs_selected.tsv"
    output: "bayespaths/{bin}/{bin}_simplif_log1.txt",
    log:    "bayespaths/Logs/{bin}_simplif.log"
    message: "Running BayesPaths on {wildcards.bin}"
    params: kmer=ASSEMBLY_K,
             read_len=READ_LENGTH,
             input_dir="subgraphs/Bin_Selected/{bin}/simplif",
             output_dir="bayespaths/{bin}"
    threads: 10
    #TODO why do we explicitly ask for python interpreter here?
    shell: """
            python3 {BAYESPATHS_DIR}/BayesPaths.py -t {BAYESPATHS_DIR}/coreCogs.tsv -l {input.Cogs} {params.input_dir} {params.kmer} {params.output_dir}/{wildcards.bin}_simplif -g {BAYESPATHS_G} -e {BAYESPATHS_DIR}/runfg_source/ -r {params.read_len} > {params.output_dir}/simplif_bayespaths_stdout.txt 2> {log}
            """


def List_bins_selected(wildcards):
    checkpoints.Select_Bin_to_run.get()
    if os.path.exists("bayespaths/List_selected_bins.txt") :
      with open("bayespaths/List_selected_bins.txt") as handle :
        BayesAGraphSVA_output=[line.rstrip() for line in handle]
    else :
      bin_paths=bin_paths_by_type("Bin_Selected")
      BayesAGraphSVA_output=expand("bayespaths/{bin}/{bin}_simplif_log1.txt", bin=[os.path.basename(b_p) for b_p in bin_paths])
    return BayesAGraphSVA_output

rule define_results:
  input:  "subgraphs/Bin_Selected/bin_selected.done",
          List_bins_selected
  output: touch("heavylifting.done"),
          "bayespaths/List_selected_bins.txt"
  run:
    with open(output[1],"w") as handle :
      for line in input[1] :
        handle.write("\n".join(line))
